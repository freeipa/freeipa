#! /usr/bin/python -E
# Authors: Martin Nagy <mnagy@redhat.com>
# Based on ipa-server-install by Karl MacMillan <kmacmillan@mentalrootkit.com>
#
# Copyright (C) 2007 - 2009  Red Hat
# see file 'COPYING' for use and warranty information
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

import traceback

from ipaserver.plugins.ldap2 import ldap2
from ipaserver.install import bindinstance, ntpinstance
from ipaserver.install.installutils import *
from ipaserver.install import installutils
from ipapython import version
from ipapython import ipautil, sysrestore
from ipalib import api, errors, util
from ipapython.config import IPAOptionParser
from ipalib.constants import DNS_ZONE_REFRESH
import krbV
import ldap

def parse_options():
    parser = IPAOptionParser(version=version.VERSION)
    parser.add_option("-p", "--ds-password", dest="dm_password",
                      sensitive=True, help="admin password")
    parser.add_option("-d", "--debug", dest="debug", action="store_true",
                      default=False, help="print debugging information")
    parser.add_option("--ip-address", dest="ip_address",
                      type="ip", ip_local=True, help="Master Server IP Address")
    parser.add_option("--forwarder", dest="forwarders", action="append",
                      type="ip", help="Add a DNS forwarder")
    parser.add_option("--no-forwarders", dest="no_forwarders", action="store_true",
                      default=False, help="Do not add any DNS forwarders, use root servers instead")
    parser.add_option("--reverse-zone", dest="reverse_zone", help="The reverse DNS zone to use")
    parser.add_option("--no-reverse", dest="no_reverse", action="store_true",
                      default=False, help="Do not create reverse DNS zone")
    parser.add_option("--zonemgr", dest="zonemgr", 
                      help="DNS zone manager e-mail address. Defaults to root")
    parser.add_option("--zone-notif", dest="zone_notif",
                      action="store_true", default=False,
                      help="Let name server receive notification when a new zone is added." \
                           "Zone refresh is turned off when zone notification is enabled")
    parser.add_option("--zone-refresh", dest="zone_refresh",
                      default=DNS_ZONE_REFRESH, type="int",
                      help="A delay between checks for new DNS zones. Defaults to %d" \
                              % DNS_ZONE_REFRESH)
    parser.add_option("-U", "--unattended", dest="unattended", action="store_true",
                      default=False, help="unattended installation never prompts the user")

    options, args = parser.parse_args()
    safe_options = parser.get_safe_opts(options)

    if options.forwarders and options.no_forwarders:
        parser.error("You cannot specify a --forwarder option together with --no-forwarders")
    elif options.reverse_zone and options.no_reverse:
        parser.error("You cannot specify a --reverse-zone option together with --no-reverse")

    if options.unattended:
        if not options.forwarders and not options.no_forwarders:
            parser.error("You must specify at least one --forwarder option or --no-forwarders option")

    if options.zone_refresh < 0:
        parser.error("negative numbers not allowed for --zone-refresh")

    if options.zone_notif:   # mutually exclusive features
        options.zone_refresh = 0

    return safe_options, options

def main():
    safe_options, options = parse_options()

    if os.getegid() != 0:
        sys.exit("Must be root to setup server")

    standard_logging_setup("/var/log/ipaserver-install.log", options.debug, filemode='a')
    print "\nThe log file for this installation can be found in /var/log/ipaserver-install.log"

    logging.debug('%s was invoked with options: %s' % (sys.argv[0], safe_options))
    logging.debug("missing options might be asked for interactively later\n")

    installutils.check_server_configuration()

    global fstore
    fstore = sysrestore.FileStore('/var/lib/ipa/sysrestore')

    print "=============================================================================="
    print "This program will setup DNS for the FreeIPA Server."
    print ""
    print "This includes:"
    print "  * Configure DNS (bind)"
    print ""
    print "To accept the default shown in brackets, press the Enter key."
    print ""

    # Check bind packages are installed
    if not bindinstance.check_inst(options.unattended):
        sys.exit("Aborting installation.")

    # Initialize the ipalib api
    cfg = dict(
        in_server=True,
        debug=options.debug,
    )
    api.bootstrap(**cfg)
    api.finalize()

    if bindinstance.named_conf_exists():
        sys.exit("\nDNS is already configured in this IPA server.")

    # Create a BIND instance
    if options.unattended and not options.dm_password:
        sys.exit("\nIn unattended mode you need to provide at least the -p option")

    dm_password = options.dm_password or read_password("Directory Manager",
                                             confirm=False, validate=False)
    if dm_password is None:
        sys.exit("\nDirectory Manager password required")
    bind = bindinstance.BindInstance(fstore, dm_password)

    # try the connection
    try:
        bind.ldap_connect()
        bind.ldap_disconnect()
    except ldap.INVALID_CREDENTIALS, e:
        sys.exit("Password is not valid!")

    # Check we have a public IP that is associated with the hostname
    if options.ip_address:
        ip = options.ip_address
    else:
        hostaddr = resolve_host(api.env.host)
        try:
            ip = hostaddr and ipautil.CheckedIPAddress(hostaddr, match_local=True)
        except Exception, e:
            print "Error: Invalid IP Address %s: %s" % (ip, e)
            ip = None

    if not ip:
        if options.unattended:
            sys.exit("Unable to resolve IP address for host name")
        else:
            ip = read_ip_address(api.env.host, fstore)
    ip_address = str(ip)
    logging.debug("will use ip_address: %s\n", ip_address)

    if options.reverse_zone and not bindinstance.verify_reverse_zone(options.reverse_zone, ip):
        sys.exit(1)

    if options.no_forwarders:
        dns_forwarders = ()
    elif options.forwarders:
        dns_forwarders = options.forwarders
    else:
        dns_forwarders = read_dns_forwarders()
    logging.debug("will use dns_forwarders: %s\n", str(dns_forwarders))

    if bind.dm_password:
        api.Backend.ldap2.connect(bind_dn="cn=Directory Manager", bind_pw=bind.dm_password)
    else:
        # See if our LDAP server is up and we can talk to it over GSSAPI
        ccache = krbV.default_context().default_ccache().name
        api.Backend.ldap2.connect(ccache)

    if options.reverse_zone:
        reverse_zone = bindinstance.normalize_zone(options.reverse_zone)
    else:
        reverse_zone = bindinstance.find_reverse_zone(ip)
        if reverse_zone is None and not options.no_reverse:
            reverse_zone = bindinstance.get_reverse_zone_default(ip)
            if not options.unattended and bindinstance.create_reverse():
                reverse_zone = bindinstance.read_reverse_zone(reverse_zone, ip)

    if reverse_zone is not None:
        print "Using reverse zone %s" % reverse_zone

    conf_ntp = ntpinstance.NTPInstance(fstore).is_enabled()

    if not options.unattended:
        print ""
        print "The following operations may take some minutes to complete."
        print "Please wait until the prompt is returned."
        print ""

    bind.setup(api.env.host, ip_address, api.env.realm, api.env.domain,
               dns_forwarders, conf_ntp, reverse_zone, zonemgr=options.zonemgr,
               zone_refresh=options.zone_refresh,
               zone_notif=options.zone_notif)
    bind.create_instance()


    print "=============================================================================="
    print "Setup complete"
    print ""
    print "\tYou must make sure these network ports are open:"
    print "\t\tTCP Ports:"
    print "\t\t  * 53: bind"
    print "\t\tUDP Ports:"
    print "\t\t  * 53: bind"

    return 0

try:
    sys.exit(main())
except SystemExit, e:
    sys.exit(e)
except KeyboardInterrupt:
    print "Installation cancelled."
except RuntimeError, e:
    print str(e)
except HostnameLocalhost:
    print "The hostname resolves to the localhost address (127.0.0.1/::1)"
    print "Please change your /etc/hosts file so that the hostname"
    print "resolves to the ip address of your network interface."
    print "The KDC service does not listen on localhost"
    print ""
    print "Please fix your /etc/hosts file and restart the setup program"
except Exception, e:
    message = "Unexpected error - see ipaserver-install.log for details:\n %s" % str(e)
    print message
    message = str(e)
    for str in traceback.format_tb(sys.exc_info()[2]):
        message = message + "\n" + str
    logging.debug(message)
    sys.exit(1)
